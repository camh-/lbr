#!/bin/bash
#
# buildroot phased build script
#
# This script exists to orchestrate the multiple phases of buildroot that are
# used to generate the toolchain, bootloader, kernel image and the base
# root filesystem.
#

# =============================================================================

MAKE=make

# =============================================================================
# Utility functions

# ----------------------------------------------------------------------------
usage()
# ----------------------------------------------------------------------------
{
	cat <<EOF
Usage: $program_name <project> <board> <phase> [target]
Phases are any name with a <project>/board/<board>/<phase> defconfig file.
A phase named "toolchain" is handled specially in that you will be prompted
to overwrite it if it already exists.
<project> is optional if CWD is the project dir.
<board> is also optional if CWD is the project's board dir.
Targets are:
  build: Build the phase. This is the default.
  menuconfig: Run make menuconfig on the target, saving the minimal defconfig
    back in the configs directory.
  oldconfig: Run make oldconfig on the target, saving the minimal defconfig
    back in the configs directory.
  clean: Remove the output directory for the phase.
EOF
	[[ -z "$1" ]] || exit "$1"
}

# ----------------------------------------------------------------------------
main()
# ----------------------------------------------------------------------------
{
	# umask 0022  # fix buildroot bug, temporary
	setup "$@" || exit 1

	if ! known_target "${target}" ; then
		echo "Unknown target: ${target}" >&2
	fi
	
	if known_target "${target}" ; then
		eval "target_${target}" "${phase}"
	else
		target_unknown "${target}" "${phase}"
	fi

	return 0
}

# ============================================================================
# TARGETS
# These functions define the top level operations of this script. Currently
# build, menuconfig, oldconfig and clean.
# An unknown target is passed onto the buildroot Makefile, so any buildroot
# target can be used

# ----------------------------------------------------------------------------
target_build()
# ----------------------------------------------------------------------------
{
	if phase_has_build_function "${phase}" ; then
		eval "build_${phase}"
	else
		default_build
	fi
}

# ----------------------------------------------------------------------------
target_menuconfig()
# ----------------------------------------------------------------------------
{
	make_output_dirs
	modify_buildroot_config menuconfig "$1"
}

# ----------------------------------------------------------------------------
target_oldconfig()
# ----------------------------------------------------------------------------
{
	make_output_dirs
	modify_buildroot_config oldconfig "$1"
}

# ----------------------------------------------------------------------------
target_clean()
# ----------------------------------------------------------------------------
{
	if [[ -n "${BRP_OUTPUT_DIR}" ]] && [[ -n "${phase}" ]]; then
		# shellcheck disable=SC2115
		rm -rf "${BRP_OUTPUT_DIR}/${phase}"
	fi
}

# ----------------------------------------------------------------------------
target_unknown()
# ----------------------------------------------------------------------------
{
	make_target "$1"
}

# ============================================================================
# BUILD target functions
# These functions build the images for each specific phases and saves them
# in the board saved image directory. The default build for a phase is to
# call `build` and then copy the resultant images to the image output
# directory. The default can be overridden by implementing a build_<phase>
# function.

# ----------------------------------------------------------------------------
build()
# ----------------------------------------------------------------------------
# build
# Build a phase into its own output directory, logging the process.
# "make $board_<phase>_defconfig" is run first to set up the configuration
# for the phase
# $1: The name of the phase. The output directory and log will be named this.
{
	make_output_dirs
	make_target all 2>&1 | tee "${log_dir}/${phase}.log"
	return "${PIPESTATUS[0]}"
}

# ----------------------------------------------------------------------------
default_build()
# ----------------------------------------------------------------------------
{
	build && copy_images
}

# ----------------------------------------------------------------------------
build_toolchain()
# TODO: Make this generically configurable in the config file (i.e. be able
# to define a phase as "protect" or something.
# ----------------------------------------------------------------------------
{
	# Give the user an option to bail out if we detect an already-
	# installed toolchain
	# source the toolchain buildroot config to get the install location
	eval "$(grep -w ^BR2_HOST_DIR "${BRP_BOARD_DIR}/config/toolchain")"
	if [[ -d "${BR2_HOST_DIR}" && "${force}" -eq 0 ]] ; then
		echo "Toolchain already exists in ${BR2_HOST_DIR}"
		read -r -p "Proceed [y/N]? " result
		if [[ "${result}" != y && "${result}" != Y ]] ; then
			echo "Aborting"
			exit 0
		fi
	fi

	default_build
}

# ----------------------------------------------------------------------------
build_final()
# ----------------------------------------------------------------------------
# A special final phase that copies the rootfs images without renaming them
# and runs a build-image.sh script from the board directory after that, with
# the intention that the script builds the flash/sdcard/etc images from the
# parts built in the various phases.
{
	if [[ -f "${brpconfig}" ]] ; then
		{ build && copy_images 'norename'; } || return
	fi

	if [[ -x "${BRP_BOARD_DIR}/build-image.sh" ]] ; then
		(
		add_host_path
		cd "${BRP_IMAGE_DIR}" && \
		"${BRP_BOARD_DIR}/build-image.sh" "${BRP_IMAGE_DIR}"
		)
	fi
}

# ============================================================================
# CONFIG target functions
# These functions implement the various config targets, currently
# menuconfig and oldconfig

# ----------------------------------------------------------------------------
create_default_config_if_missing()
# ----------------------------------------------------------------------------
{
	defaultconfig="${BRP_BOARD_DIR}/toolchain/config/toolchain_client"

	# Create a default config file if one does not exist
	if [[ ! -f "${brpconfig}" ]] ; then
		mkdir -p "${brpconfig%/*}"
		if [[ -f "${defaultconfig}" ]] ; then
			run cp "${defaultconfig}" "${brpconfig}"
		else
			run touch "${brpconfig}"
		fi
	fi
}

# ----------------------------------------------------------------------------
modify_buildroot_config()
# ----------------------------------------------------------------------------
# modify_buildroot_config make_target
# Run "make <make_target>" for <phase> and save the resulting minimal
# defconfig in the configs directory.
# If there is an existing minimal defconfig for <phase>, it will be used as
# the basis of the menuconfig, otherwise a default config is used.
{
	make_target="$1"

	create_default_config_if_missing "$1"

	make_target "${make_target}" \
	&& run ${MAKE} "${make_args[@]}" savedefconfig \
	&& cp "${srcconfig}" "${brpconfig}"
}

# ============================================================================

# ----------------------------------------------------------------------------
make_target()
# ----------------------------------------------------------------------------
{
	make_target="$1"

	if [[ ! -f "${brpconfig}" ]] ; then
		echo "No config for phase ${phase} at ${brpconfig}" >&2
		return 1
	fi

	cp "${brpconfig}" "${srcconfig}" \
	&& run ${MAKE} "${make_args[@]}" "${defconfig}" \
	&& run ${MAKE} "${make_args[@]}" "${make_target}"
}

# ----------------------------------------------------------------------------
copy_image()
# ----------------------------------------------------------------------------
# copy_image <image_name> [dest_image_name]
# Copy an image from an output directory into the board saved image directory.
# $1: The name of the image to copy.
# $2: (Optional) The name of the image after copying. If not supplied, the
#     image keeps the same name.
{
	src="${BRP_OUTPUT_DIR}/${phase}/images/$1"
	dest="${BRP_IMAGE_DIR}"
	[[ -n "$2" ]] && dest="$dest/$2"
	run cp -a "$src" "$dest"
}

# ----------------------------------------------------------------------------
copy_images()
# ----------------------------------------------------------------------------
# copy_images
# Copy all images from <phase>'s image directory, except the uncompressed
# rootfs image in there is a compressed one. The rootfs image is renamed
# to include <phase> in its name, unless "$1" == 'norename'.
{
	srcdir="${BRP_OUTPUT_DIR}/${phase}/images"
	for src in "${srcdir}"/* ; do
		[[ "$src" = "${srcdir}/*" ]] && continue
		srcname="${src##*/}"
		if [[ "$1" != 'norename' ]] ; then
			newname="${srcname/rootfs/rootfs-${phase}}"
		fi
		# Don't copy uncompressed rootfs if there's a compressed one.
		if [[ "$srcname" =~ ^rootfs\.[^\.]*$ ]] && globmatch "${src}.*"
		then
			continue
		fi
		copy_image "$srcname" "${newname-}"
	done
}

# ============================================================================
# UTILITY

# ----------------------------------------------------------------------------
phase_has_build_function()
# ----------------------------------------------------------------------------
{
	[[ "$(type -t "build_${1}")" = function ]]
}

# ----------------------------------------------------------------------------
known_target()
# ----------------------------------------------------------------------------
{
	[[ "$(type -t "target_${1}")" = function ]]
}

# ----------------------------------------------------------------------------
run()
# ----------------------------------------------------------------------------
{
	echo "$@"
	[[ "${dryrun}" -ne 0 ]] || "$@"
}

# ----------------------------------------------------------------------------
start_tmp()
# ----------------------------------------------------------------------------
# Create a temporary directory and put its name in $tmp_dir. 
# This function will install an EXIT handler so that if the shell script
# exits before the directory is removed then it will get removed on exit.
# The caller should call end_tmp() when they no longer need the temp dir
# Returns true if we could create the tmp_dir, false if not.
{
	[[ -z "${tmp_dir}" ]] || return 1
	trap clean_tmp EXIT
	tmp_dir=$(mktemp -d)
}

# ----------------------------------------------------------------------------
end_tmp()
# ----------------------------------------------------------------------------
# End use of the global temp directory.
# This function will remove the temp directory and EXIT handler.
{
	clean_tmp
}

# ----------------------------------------------------------------------------
clean_tmp()
# ----------------------------------------------------------------------------
# Remove the directory in $tmp_dir if that variable is set.
{
	[[ -n "${tmp_dir}" ]] || return 1
	rm -rf "${tmp_dir}"
	tmp_dir=""
	trap - EXIT
}

# ----------------------------------------------------------------------------
globmatch()
# ----------------------------------------------------------------------------
# $1: A glob pattern
# Returns true if $1 matches any files, false if not
{
	compgen -G "$1" > /dev/null
}

# ----------------------------------------------------------------------------
sep()
# ----------------------------------------------------------------------------
# Output arguments seperated by $1
{
	# shellcheck disable=SC2030
	(IFS="$1"; shift; echo "$*")
}

# ----------------------------------------------------------------------------
prepend_path()
# ----------------------------------------------------------------------------
# Prepend arguments to $PATH
{
	PATH=$(sep : "$@" "${PATH}")
}

# ----------------------------------------------------------------------------
add_host_path()
# ----------------------------------------------------------------------------
# Add the host tools to PATH. This is the "host" directory of a build phase.
# Currently that is hardcoded as the "host" phase and must be a phase of
# the current board. This will probably change in future to be more flexible
# (probably to have it in the toolchain "board" as the host tools do not
# need to be defined or built for every board).
{
	prepend_path "${BRP_OUTPUT_DIR}"/host/host/{,usr/}{bin,sbin}
}

# ============================================================================
# SETUP
# Functions to read the config and set up the environment that the rest of
# this script depends on

# ----------------------------------------------------------------------------
setup()
# ----------------------------------------------------------------------------
{
	program_name=${0##*/}

	BRP_ROOT=$(find_brp_root)

	parse_args "$@"

	load_config || return 1

	BRP_PROJECT_DIR="${BRP_ROOT}/${project}"
	BRP_OUTPUT_ROOT="${output_root:-${BRP_PROJECT_DIR}/output}"
	BRP_OUTPUT_DIR="${BRP_OUTPUT_ROOT}/${board}"
	BRP_IMAGE_DIR="${BRP_OUTPUT_DIR}"/images
	BRP_BOARD_DIR="${BRP_PROJECT_DIR}/board/${board}"

	find_buildroot

	check_config || return 1

	defconfig="${board}_${phase}_defconfig"
	srcconfig="${BRP_PROJECT_DIR}/configs/${defconfig}"
	brpconfig="${BRP_BOARD_DIR}/config/${phase}"

	log_dir="${BRP_OUTPUT_DIR}"/logs
	tmp_dir=""

	make_args=(
		-C "${buildroot}"
		"O=${BRP_OUTPUT_DIR}/${phase}"
		"BR2_EXTERNAL=${BRP_ROOT}/core:${BRP_PROJECT_DIR}"
	)

	[[ "$V" == '1' ]] && make_args+=("V=1")

	force=0
	dryrun=0

	export BRP_PROJECT_DIR BRP_OUTPUT_ROOT BRP_OUTPUT_DIR BRP_IMAGE_DIR \
		BRP_BOARD_DIR
}

# ----------------------------------------------------------------------------
parse_args()
# ----------------------------------------------------------------------------
{
	# Normal usage is:
	#  brp <project> <board> <config> [action]
	# but we can infer project and board from $PWD if appropriate.
	# If we are in the project dir, then we don't require that arg.
	# If we are in a projects board dir, we don't require those args.
	if [[ ${PWD} =~ ${BRP_ROOT}/([^/]*)(/board/([^/]*))? ]]; then
		if [[ -n "${BASH_REMATCH[3]-}" ]]; then
			set -- "${BASH_REMATCH[3]}" "$@"
		fi
		set -- "${BASH_REMATCH[1]}" "$@"
	fi

	project="$1"
	board="$2"
	phase="$3"
	target="${4:-build}"

	[[ -n "${project}" ]] || usage 1 >&2
	[[ -n "${board}" ]] || usage 1 >&2
	[[ -n "${phase}" ]] || usage 1 >&2
}

# ----------------------------------------------------------------------------
find_brp_root()
# ----------------------------------------------------------------------------
{
	# If we are inside a brp project dir, then use its parent as the
	# brp root. Otherwise try to find it based on the path to $0 and
	# failing that, $PWD.
	# A brp project dir is also a BR2_EXTERNAL dir, which requires
	# external.desc to exist. Use that to determine if we are in a brp
	# project dir.
	local prj_dir=$(realpath "${PWD}")
	while [[ "${prj_dir}" ]] && ! [[ -f "${prj_dir}/external.desc" ]]; do
		prj_dir="${prj_dir%/*}"
	done

	if [[ "${prj_dir}" ]]; then
		prog_dir="${prj_dir%/*}"
	elif [[ "$0" =~ / ]]; then
		prog_dir=$(realpath "${0%/*}")
	else
		prog_dir=''
	fi

	printf '%s\n' "${prog_dir:-${PWD}}"
}

# ----------------------------------------------------------------------------
find_buildroot()
# ----------------------------------------------------------------------------
{
	if [[ -z "${buildroot-}" ]]; then
		if [[ -e "${BRP_PROJECT_DIR}/buildroot" ]]; then
			buildroot="${BRP_PROJECT_DIR}/buildroot"
		elif [[ -e "${BRP_ROOT}"/buildroot ]]; then
			buildroot="${BRP_ROOT}/buildroot"
		fi
	fi
}

# ----------------------------------------------------------------------------
load_config()
# ----------------------------------------------------------------------------
{
	local -a xdg
	IFS=: read -r -a xdg <<< "${XDG_CONFIG_DIRS:-/etc/xdg}"
	local -a search=(
		"${xdg[@]/%//brp}"
		"${XDG_CONFIG_HOME:-$HOME/.config}/brp"
		"${project}/brp.conf")
	for path in "${search[@]}" ; do
		if [[ -f "$path" ]] ; then
			# shellcheck disable=SC1090
			source "$path"
		fi
	done

	return 0
}

# ----------------------------------------------------------------------------
check_config()
# ----------------------------------------------------------------------------
{
	if [[ -z "${buildroot}" ]] ; then
		echo "'buildroot' not set in config. Where is buildroot?" >&2
		return 1
	fi
	if ! [[ -d "${BRP_BOARD_DIR}" ]] ; then
		echo "board dir missing: ${BRP_BOARD_DIR}" >&2
		return 1
	fi
	return 0
}

# ----------------------------------------------------------------------------
make_output_dirs()
# ----------------------------------------------------------------------------
{
	run mkdir -p "${BRP_OUTPUT_DIR}"
	run mkdir -p "${BRP_IMAGE_DIR}"
	run mkdir -p "${log_dir}"
}

# ----------------------------------------------------------------------------
[[ "$(caller)" != "0 "* ]] || main "$@"
