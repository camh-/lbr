#!/bin/bash
# vim: set ts=8 sw=2 sts=2 et sta fileencoding=utf-8:
#
# -----------------------------------------------------------------------------
# buildroot phased build script
#
# This script exists to orchestrate the multiple phases of buildroot that are
# used to generate the sdk, bootloader, kernel image and the base
# root filesystem.
#

# =============================================================================

script_dir=$(dirname "$(realpath "$0")")
# shellcheck source=/dev/null
source "${script_dir}/kconfig.sh"

# -----------------------------------------------------------------------------

MAKE=make

declare -A OPTIONS=(
  [global]='h'
  [linuxup]='go'
)

OPT_linuxup_git=false
OPT_linuxup_oldconfig=false

# ----------------------------------------------------------------------------
usage() {
  cat <<EOF
Usage: $program_name [options] <target> [target-options] [project] [board] <phase>
Options are:
  -h: Show this help message

Phases are defined with a <project>/board/<board>/config/<phase> defconfig file.
<project> is optional if CWD is the project dir.
<board> is also optional if CWD is the project's board dir.
Targets are:
  build:   Build the phase.
  *config: Run make *config on the target, saving the minimal phase defconfig.
  clean:   Remove the output directory for the phase.
  linuxup: Update the linux kernel config to the next version of linux.
    -g:      Add new config files to git before savedefconfig.
  <other>: Other target are passed through to buildroot make.
EOF
[[ -z "$1" ]] || exit "$1"
}

# ----------------------------------------------------------------------------
main() {
  # umask 0022  # fix buildroot bug, temporary
  setup "$@" || exit 1

  if known_target "${target}" ; then
    eval "target_${target}" "${phase}"
  else
    target_unknown "${target}" "${phase}"
  fi

  return 0
}

# ============================================================================
# TARGETS
# These functions define the top level operations of this script. Currently
# build, menuconfig, oldconfig and clean.
# An unknown target is passed onto the buildroot Makefile, so any buildroot
# target can be used

# ----------------------------------------------------------------------------
target_build() {
  if phase_has_build_function "${phase}" ; then
    eval "build_${phase}"
  else
    build
  fi
}

# ----------------------------------------------------------------------------
target_clean() {
  if [[ -n "${BRP_OUTPUT_DIR}" ]] && [[ -n "${phase}" ]]; then
    # shellcheck disable=SC2115
    run rm -rf "${BRP_OUTPUT_DIR}/${phase}"
  fi
}

# ----------------------------------------------------------------------------
# linuxup: Update the linux config to the next available version.
# The phase must have a linux build in the br2 config.
#
# Linux kernel upgrading works like this:
# Look in the current br2 merged defconfig:
# * You must be using a custom git repo (BR2_LINUX_KERNEL_CUSTOM_GIT=y)
# * Get the current version (BR2_LINUX_KERNEL_CUSTOM_REPO_VERSION)
# * Get the latest point release of next minor version from repo
# * Get the custom config file (BR2_LINUX_KERNEL_CUSTOM_CONFIG_FILE)
#   + Extract directory from custom config file
#   + Make new sibling directory with major.minor of next kernel version
#   + Copy files from old dir to new dir
# * Do the same for fragment files (BR2_LINUX_KERNEL_CUSTOM_FRAGMENT_FILES)
# * Change br2 merged defconfig to update version, config and fragments.
# * Generate full br2 config from merged defconfig
# * Extract kernel version (linux-patch?)
# * Copy config from config file dir to linux build dir
# * Run oldconfig on the kernel
# * Run make linux-config-demerge
target_linuxup() {
  get_linux_br2_config
  local current_tag current_version next_tag next_version
  current_tag="${BR2_LINUX_KERNEL_CUSTOM_REPO_VERSION}"
  current_version=$(extract_major_minor "${current_tag}")
  next_tag=$(next_linux_version "${BR2_LINUX_KERNEL_CUSTOM_REPO_URL}" "${current_tag}")
  next_version=$(extract_major_minor "${next_tag}")

  kconfig_str_set BR2_LINUX_KERNEL_CUSTOM_REPO_VERSION "${next_tag}" "${brpconfig}"
  local dotconfig
  dotconfig=$(uplift_linux_configs "${current_version}" "${next_version}")

  local config_target=linux-configure
  if "${OPT_linuxup_oldconfig}"; then
    if [[ -n "${dotconfig}" ]]; then
      config_target=linux-oldconfig
    else
      printf 'No dot config file available for oldconfig\n' >&1
      exit 1
    fi
  fi
  make_target "${config_target}"
  make_target linux-config-demerge
}

# ----------------------------------------------------------------------------
target_unknown() {
  # All buildroot config targets end with config and do not contain a
  # hyphen. Those with a hyphen configure buildroot packages and not
  # buildroot itself so should be treated as a normal target.
  if [[ "$1" =~ ^[^-]*config$ ]]; then
    make_config_target "$1"
  else
    make_target "$1"
  fi
}

# ============================================================================
# BUILD target functions
# These functions build the images for each specific phases and saves them
# in the board saved image directory. The default build for a phase is to
# call `build` and then copy the resultant images to the image output
# directory. The default can be overridden by implementing a build_<phase>
# function.

# ----------------------------------------------------------------------------
# build
# Build a phase into its own output directory, logging the process.
# "make defconfig" is run first to set up the configuration for the phase,
#   with BR2_DEFCONFIG pointing to the phase's config.
# $1: (optional) Target to build. Defaults to "all".
build() {
  # If the defconfig fragment has define BR2_HOST_DIR, we check
  # if it exists and ask for confirmation to proceed if it does.
  # This is to protect against mistakes which might overwrite
  # an external toolchain.
  kconfig_get BR2_HOST_DIR "${brpconfig}"
  if [[ -n "${BR2_HOST_DIR-}" && -d "${BR2_HOST_DIR}" ]]; then
    echo 'Host dir already exists:' "${BR2_HOST_DIR}"
    read -r -p 'Proceed [y/N]? ' result
    if [[ "${result}" != y && "${result}" != Y ]] ; then
      echo "Aborting"
      exit 0
    fi
  fi

  make_target "${1:-all}" 2>&1 | tee "${log_dir}/${phase}.log"
  return "${PIPESTATUS[0]}"
}

# ----------------------------------------------------------------------------
build_sdk() {
  build sdk
}

# ============================================================================
# CONFIG target functions
# These functions implement the various config targets, currently
# menuconfig and oldconfig

# ----------------------------------------------------------------------------
# make_config_target make_target
# Run "make <make_target>" for <phase> and save the resulting minimal
# defconfig in the configs directory.
# If there is an existing minimal defconfig for <phase>, it will be used as
# the basis of the menuconfig, otherwise a default config is used.
make_config_target() {
  make_target="$1"

  [[ -f "${brpconfig}" ]] || run touch "${brpconfig}"

  merge_config
  run ${MAKE} "${make_args[@]}" defconfig "${make_target}" savedefconfig
  demerge_config
}

# ----------------------------------------------------------------------------
# Merge the config fragments listed in the BRP_CONFIG_FRAGMENTS of the
# current phases fragment file and write out a defconfig file to the
# output directory (BR2_DEFCONFIG).
merge_config() {
  kconfig_get BRP_CONFIG_FRAGMENTS "${brpconfig}"
  local -a fragments
  # shellcheck disable=SC2086
  # We want to split on spaces for BRP_CONFIG_FRAGMENTS
  fragments=($(find_fragments ${BRP_CONFIG_FRAGMENTS}))
  kconfig_merge "${fragments[@]}" "${brpconfig}" > "${BR2_DEFCONFIG}"
}

# ----------------------------------------------------------------------------
# Subtract the fragments listed in the BRP_CONFIG_FRAGMENTS of the current
# phases defconfig file (BR2_DEFCONFIG) from that defconfig file and write
# out a fragment file containing the remaining config options. Whiteout
# entries are written where the current phases defconfig file does not have
# a setting for a variable that is set in one of the fragments. This occurs
# when a defconfig resets a setting to a default value that has been set to
# a non-default value in a fragment. Omitting the setting altogether in the
# fragment would see the setting have the value from the fragment and not
# the default value when the fragments are re-merged.
demerge_config() {
  kconfig_get BRP_CONFIG_FRAGMENTS "${BR2_DEFCONFIG}"
  local -a fragments
  # shellcheck disable=SC2086
  # We want to split on spaces for BRP_CONFIG_FRAGMENTS
  fragments=($(find_fragments ${BRP_CONFIG_FRAGMENTS}))
  kconfig_demerge "${BR2_DEFCONFIG}" "${fragments[@]}" > "${brpconfig}"
}

# ----------------------------------------------------------------------------
# find_fragments <fragment>...
# Find each of the given fragments in the fragment search path.
find_fragments() {
  for fragment; do
    find_fragment "${fragment}" || exit 1
  done
}

# ----------------------------------------------------------------------------
# find_fragment <fragment>
# $1: name of fragment file.
# Search for a defconfig fragment named <fragment> starting at the current
# board directory, and following the chain of parents back from the board
# dir. Also look in the project directory and the core directory.
# The search stops when the named fragment is found.
find_fragment() {
  local fragment="$1" dir
  local -a parents cfg_dirs
  get_parents parents "${BRP_BOARD_DIR}"
  cfg_dirs=("${BRP_BOARD_DIR}" \
    "${parents[@]}" \
    "${BRP_PROJECT_DIR}" \
    "${BRP_CORE_DIR}"
  )
  for dir in "${cfg_dirs[@]}"; do
    local f="${dir}/config/${fragment}"
    if [[ -f "${f}" ]]; then
      printf '%s\n' "${f}"
      return 0
    fi
  done

  printf 'Could not find defconfig fragment: %s\n' "${fragment}" >&2
  return 1
}

# ----------------------------------------------------------------------------
# get_parents <array_name> <board_dir>
# Find all the parent directories of a board directory.
# Parent directories are found by following the "parent" symlink in each
# board dir until there are no more "parent" symlinks.
# $1: Name of array to put the parent dirs in.
# $2: The board directory to start from.
get_parents() {
  local -n _parents="$1"
  local dir="$2"

  while [[ -d "${dir}/parent" ]]; do
    dir=$(realpath "${dir}/parent")
    _parents+=("${dir}")
  done
}

# ============================================================================

# ----------------------------------------------------------------------------
make_target() {
  make_target="$1"

  if [[ ! -f "${brpconfig}" ]] ; then
    echo "No config for phase ${phase} at ${brpconfig}" >&2
    return 1
  fi

  merge_config
  run ${MAKE} "${make_args[@]}" defconfig \
    && post_config \
    && run ${MAKE} "${make_args[@]}" olddefconfig \
    && run ${MAKE} "${make_args[@]}" "${make_target}"
}

# ----------------------------------------------------------------------------
# Run the post-config.sh script in each BR2_EXTERNAL dir. Set BR2_CONFIG
# appropriately.
post_config() {
  IFS=: read -r -a ext_dirs <<<"${BR2_EXTERNAL}"
  for dir in "${ext_dirs[@]}"; do (
    if [[ -x "${dir}/post-config.sh" ]]; then
      message post-config "${dir}"
      BR2_CONFIG="${BRP_OUTPUT_DIR}/${BRP_PHASE}/.config"
      export BR2_CONFIG
      cd "${dir}" && run "${dir}/post-config.sh" "${dir}"
    fi
  ) done
}

# ============================================================================
# Linux kernel config upgrading
#
# ----------------------------------------------------------------------------
get_linux_br2_config() {
  if ! kconfig_y BR2_LINUX_KERNEL "${brpconfig}"; then
    printf 'Linux kernel build not enabled in this phase\n' >&2
    exit 1
  fi

  if ! kconfig_y BR2_LINUX_KERNEL_CUSTOM_GIT "${brpconfig}"; then
    printf 'You need to be using a custom git repository\n' >&2
    exit 1
  fi

  if ! kconfig_y BR2_LINUX_KERNEL_USE_CUSTOM_CONFIG "${brpconfig}"; then
    printf 'You need to be using a custom config to update it\n' >&2
    exit 1
  fi

  kconfig_get BR2_LINUX_KERNEL_CUSTOM_REPO_URL "${brpconfig}"
  kconfig_get BR2_LINUX_KERNEL_CUSTOM_REPO_VERSION "${brpconfig}"
  kconfig_get BR2_LINUX_KERNEL_CUSTOM_CONFIG_FILE "${brpconfig}"
  kconfig_get BR2_LINUX_KERNEL_CONFIG_FRAGMENT_FILES "${brpconfig}"
}

# ----------------------------------------------------------------------------
# next_linux_version <git_repository> <current_version>
# Find the next linux version from <git_repository> after <current_version>
# that is a linux git version tag. Output the full version tag.
# If there is no next minor version, the latest point release version for the
# current minor version is output.
# Returns true if a version was found, false if not.
next_linux_version() {
  # shellcheck disable=SC2016
  # We don't want to expand vars, but shellcheck thinks we do.
  find_next='
    $1"."$2 == last {if (vers) {print vers} else {print $0}; found=1; exit}
    $1"."$2 != seen {seen=$1"."$2; vers=$0}
    END {if (found) {exit 0}; exit 1}
  '
  local version
  if version=$(extract_major_minor "$2"); then
    git ls-remote --tags "$1" \
      | awk -F/ '/(\^\{\}$|-)/ {next} {print $3}' \
      | sort -Vr \
      | awk -F. -v last="v${version}" "${find_next}"
  else
    return 1
  fi
}

# ----------------------------------------------------------------------------
# extract_major_minor <version_tag>
# Extract the major.minor version from a linux version tag and output to
# stdout. Returns true if the version could be extracted, false if not.
extract_major_minor() {
  if ! [[ "$1" =~ v([0-9]+\.[0-9]+)\. ]]; then
    printf 'Cannot find v<major>.<minor> in kernel version %s\n' "$1" >&2
    return 1
  fi
  echo "${BASH_REMATCH[1]}"
  return 0
}

# ----------------------------------------------------------------------------
# uplift_linux_configs <current_version> <next_version>
# Uplift the linux config file and the linux config fragments from
# <current_version> to <next_version> and update the br2 phase defconfig
# fragment with the uplifted paths.
uplift_linux_configs() {
  local cur="$1" next="$2"

  # Uplift the (def)config file.
  local new_config
  new_config=$(uplift_linux_config "${cur}" "${next}" "${BR2_LINUX_KERNEL_CUSTOM_CONFIG_FILE}")
  kconfig_str_set BR2_LINUX_KERNEL_CUSTOM_CONFIG_FILE "${new_config}" "${brpconfig}"

  # Uplift the config file if it exists and was not uplifted before.
  if ! [[ "${BR2_LINUX_KERNEL_CUSTOM_CONFIG_FILE}" =~ /"${cur}"/config$ ]]; then
    local dotconfig="${BR2_LINUX_KERNEL_CUSTOM_CONFIG_FILE%/*}/config"
    if [[ -f "$(envsubst <<<"${dotconfig}")" ]]; then
      # Leave the output of uplift_linux_config to echo back to the caller of us.
      uplift_linux_config "${cur}" "${next}" "${dotconfig}"
    fi
  fi

  # Uplift each config file fragment.
  local fragment
  local -a linux_fragments
  for fragment in ${BR2_LINUX_KERNEL_CONFIG_FRAGMENT_FILES}; do
    linux_fragments+=( "$(uplift_linux_config "${cur}" "${next}" "${fragment}")" )
  done
  kconfig_str_set BR2_LINUX_KERNEL_CONFIG_FRAGMENT_FILES "${linux_fragments[*]}" "${brpconfig}"
}

# ----------------------------------------------------------------------------
# uplift_linux_config <current_version> <next_version> <config_val>
# If <config_val> is in a directory named <current_version>, copy the file
# to a new directory named <next_version> and output the path to the new
# config file. Otherwise just echo the name of the config_file.
# Note, we need to expand $ refs in the config file name so we can copy the
# config file, but we output the uplifted setting value without performing
# the expansion.
uplift_linux_config() {
  local current_version="$1" next_version="$2" config_val="$3"
  if [[ "${config_val}" =~ ^(.*)/"${current_version}"/(.*)$ ]]; then
    local new_dir="${BASH_REMATCH[1]}/${next_version}"
    config_val="${new_dir}/${BASH_REMATCH[2]}"
    install -D "$(envsubst <<<"$3")" "$(envsubst <<<"${config_val}")"
    if "${OPT_linuxup_git}"; then
      git add "$(envsubst <<<"${config_val}")"
    fi
  fi
  echo "${config_val}"
}

# ============================================================================
# UTILITY

# ----------------------------------------------------------------------------
phase_has_build_function() {
  [[ "$(type -t "build_${1}")" = function ]]
}

# ----------------------------------------------------------------------------
known_target() {
  [[ "$(type -t "target_${1}")" = function ]]
}

# ----------------------------------------------------------------------------
target_has_options() {
  [[ "$(type -t "handle_${1}_option")" = function ]]
}

# ----------------------------------------------------------------------------
run() {
  echo "$@"
  [[ "${dryrun}" -ne 0 ]] || "$@"
}

# ----------------------------------------------------------------------------
message() {
  tput smso
  printf '>>> %s\n' "$*"
  tput rmso
}

# ============================================================================
# SETUP
# Functions to read the config and set up the environment that the rest of
# this script depends on

# ----------------------------------------------------------------------------
setup() {
  program_name=${0##*/}

  BRP_ROOT=$(find_brp_root)

  parse_args "$@"

  load_config || return 1

  BRP_CORE_DIR="${BRP_ROOT}/core"
  BRP_PROJECT_DIR="${BRP_ROOT}/${project}"
  BRP_OUTPUT_ROOT="${output_root:-${BRP_PROJECT_DIR}/output}"
  BRP_OUTPUT_DIR="${BRP_OUTPUT_ROOT}/${board}"
  BRP_IMAGE_DIR="${BRP_OUTPUT_DIR}"/images
  BRP_BOARD_DIR="${BRP_PROJECT_DIR}/board/${board}"

  BRP_PROJECT="${project}"
  BRP_BOARD="${board}"
  BRP_PHASE="${phase}"

  find_buildroot

  check_config || return 1

  brpconfig="${BRP_BOARD_DIR}/config/${phase}"

  log_dir="${BRP_OUTPUT_DIR}"/logs

  export BR2_EXTERNAL="${BRP_CORE_DIR}:${BRP_PROJECT_DIR}"
  export BR2_DEFCONFIG="${BRP_OUTPUT_DIR}/${phase}/defconfig"
  make_args=(
    -C "${buildroot}"
    "O=${BRP_OUTPUT_DIR}/${phase}"
  )

  [[ "$V" == '1' ]] && make_args+=("V=1")

  dryrun=0

  make_output_dirs

  export BRP_ROOT BRP_PROJECT_DIR BRP_OUTPUT_ROOT BRP_OUTPUT_DIR \
    BRP_IMAGE_DIR BRP_BOARD_DIR BRP_PROJECT BRP_BOARD BRP_PHASE
}

# ----------------------------------------------------------------------------
parse_args() {
  # Normal usage is:
  #  brp [options] <target> [target-options] <project> <board> <config>
  # but we can infer project and board from $PWD if appropriate.
  # If we are in the project dir, then we don't require that arg.
  # If we are in a projects board dir, we don't require those args.
  # Use these CWD defaults if not explicitly given on the cmdline.
  if [[ ${PWD} =~ ${BRP_ROOT}/([^/]*)(/board/([^/]*))? ]]; then
    if [[ -n "${BASH_REMATCH[3]-}" ]]; then
      board="${BASH_REMATCH[3]}"
    fi
    project="${BASH_REMATCH[1]}"
  fi

  parse_options 'global' "$@"
  shift $((OPTIND-1))

  (($# > 0)) || usage 1 >&2

  target="$1"; shift
  parse_options "${target}" "$@"
  shift $((OPTIND-1))

  (( $# == 3 )) && { project="$1"; shift; }
  (( $# == 2 )) && { board="$1"; shift; }
  phase="$1"

  [[ -n "${project}" ]] || usage 1 >&2
  [[ -n "${board}" ]] || usage 1 >&2
  [[ -n "${phase}" ]] || usage 1 >&2
}

# ----------------------------------------------------------------------------
parse_options() {
  target="$1"; shift
  while getopts ":${OPTIONS[${target}]-}" opt; do
    handle_getopt_errors "${target}" "${opt}"
    handle_option "${target}" "${opt}"
  done
}

# ----------------------------------------------------------------------------
handle_option() {
  if target_has_options "$1"; then
    handle_${target}_option "${opt}"
  fi
}

# ----------------------------------------------------------------------------
handle_global_option() {
  case "$1" in
    h)
      usage 0
      ;;
  esac
}

# ----------------------------------------------------------------------------
handle_linuxup_option() {
  case "$1" in
    g)
      OPT_linuxup_git=true
      ;;
    o)
      OPT_linuxup_oldconfig=true
      ;;
  esac
}

# ----------------------------------------------------------------------------
handle_getopt_errors() {
  case "$2" in
    \?)
      printf 'Invalid %s option: -%s\n\n' "$1" "${OPTARG}" >&2
      usage 1 >&2
      ;;
    :)
      printf '%s option -%s requires an argument\n\n' "$1" "${OPTARG}" >&2
      usage 1 >&2
      ;;
  esac
}

# ----------------------------------------------------------------------------
find_brp_root() {
  # If we are inside a brp project dir, then use its parent as the
  # brp root. Otherwise try to find it based on the path to $0 and
  # failing that, $PWD.
  # A brp project dir is also a BR2_EXTERNAL dir, which requires
  # external.desc to exist. Use that to determine if we are in a brp
  # project dir.
  local prj_dir
  prj_dir=$(realpath "${PWD}")
  while [[ "${prj_dir}" ]] && ! [[ -f "${prj_dir}/external.desc" ]]; do
    prj_dir="${prj_dir%/*}"
  done

  if [[ "${prj_dir}" ]]; then
    prog_dir="${prj_dir%/*}"
  elif [[ "$0" =~ / ]]; then
    prog_dir=$(dirname "$(realpath "$0")")
  else
    prog_dir=''
  fi

  printf '%s\n' "${prog_dir:-${PWD}}"
}

# ----------------------------------------------------------------------------
find_buildroot() {
  if [[ -z "${buildroot-}" ]]; then
    if [[ -e "${BRP_PROJECT_DIR}/buildroot" ]]; then
      buildroot="${BRP_PROJECT_DIR}/buildroot"
    elif [[ -e "${BRP_ROOT}"/buildroot ]]; then
      buildroot="${BRP_ROOT}/buildroot"
    fi
  fi
}

# ----------------------------------------------------------------------------
load_config() {
  local -a xdg
  IFS=: read -r -a xdg <<< "${XDG_CONFIG_DIRS:-/etc/xdg}"
  local -a search=(
  "${xdg[@]/%//brp}"
  "${XDG_CONFIG_HOME:-$HOME/.config}/brp"
  "${project}/brp.conf")
  for path in "${search[@]}" ; do
    if [[ -f "$path" ]] ; then
      # shellcheck disable=SC1090
      source "$path"
    fi
  done

  return 0
}

# ----------------------------------------------------------------------------
check_config() {
  if [[ -z "${buildroot}" ]] ; then
    echo "'buildroot' not set in config. Where is buildroot?" >&2
    return 1
  fi
  if ! [[ -d "${BRP_BOARD_DIR}" ]] ; then
    echo "board dir missing: ${BRP_BOARD_DIR}" >&2
    return 1
  fi
  return 0
}

# ----------------------------------------------------------------------------
make_output_dirs() {
  for dir in "${BRP_OUTPUT_DIR}" "${BRP_IMAGE_DIR}" "${log_dir}" \
    "${BRP_OUTPUT_DIR}/${phase}"; do
  if [[ ! -d "${dir}" ]]; then
    if [[ ! -e "${dir}" ]]; then
      run mkdir -p "${dir}"
    else
      echo "Cannot mkdir ${dir}" >&2
      exit 1
    fi
  fi
done
}

# ----------------------------------------------------------------------------
[[ "$(caller)" == 0\ * ]] && main "$@"
