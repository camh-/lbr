#!/bin/bash
#
# buildroot phased build script
#
# This script exists to orchestrate the multiple phases of buildroot that are
# used to generate the toolchain, bootloader, kernel image and the base
# root filesystem.
#

# =============================================================================

MAKE=make

# =============================================================================
# Utility functions

# ----------------------------------------------------------------------------
usage()
# ----------------------------------------------------------------------------
{
	cat <<EOF
Usage: $program_name <board> <phase> [target]
Phases are any name with a <board>_<phase>_deconfig file in the configs/
directory. A phase named "toolchain" is handled specially in that you will
be prompted to overwrite it if it already exists.
Targets are:
  build: Build the phase. This is the default.
  menuconfig: Run make menuconfig on the target, saving the minimal defconfig
    back in the configs directory.
  oldconfig: Run make oldconfig oon the target, saving the minimal defconfig
    back in the configs directory.
  clean: Remove the output directory for the phase.
EOF
	[ -z "${1}" ] || exit "${1}"
}

# ----------------------------------------------------------------------------
main()
# ----------------------------------------------------------------------------
{
	# umask 0022  # fix buildroot bug, temporary
	load_config || exit 1
	set_vars "$@"
	check_config || exit 1

	if ! known_target "${target}" ; then
		echo "Unknown target: ${target}" >&2
	fi
	
	if known_target "${target}" ; then
		eval target_${target} ${phase}
	else
		target_unknown "${target}" "${phase}"
	fi

	return 0
}

# ============================================================================
# TARGETS
# These functions define the top level operations of this script. Currently
# build, menuconfig, oldconfig and clean.
# An unknown target is passed onto the buildroot Makefile, so any buildroot
# target can be used

# ----------------------------------------------------------------------------
target_build()
# ----------------------------------------------------------------------------
{
	make_output_dirs
	if phase_has_build_function "${phase}" ; then
		eval build_${phase}
	else
		default_build
	fi
}

# ----------------------------------------------------------------------------
target_menuconfig()
# ----------------------------------------------------------------------------
{
	make_output_dirs
	create_default_config_if_missing "$1"
	modify_buildroot_config menuconfig "$1"
}

# ----------------------------------------------------------------------------
target_oldconfig()
# ----------------------------------------------------------------------------
{
	make_output_dirs
	modify_buildroot_config oldconfig "$1"
}

# ----------------------------------------------------------------------------
target_clean()
# ----------------------------------------------------------------------------
{
	rm -rf "${output_location}/${phase}"
}

# ----------------------------------------------------------------------------
target_unknown()
# ----------------------------------------------------------------------------
{
	make_target "$1" "$2"
}

# ============================================================================
# BUILD target functions
# These functions build the images for each specific phases and saves them
# in the board saved image directory. The default build for a phase is to
# call `build` and then copy the resultant images to the image output
# directory. The default can be overridden by implementing a build_<phase>
# function.

# ----------------------------------------------------------------------------
build()
# ----------------------------------------------------------------------------
# build
# Build a phase into its own output directory, logging the process.
# "make $board_<phase>_defconfig" is run first to set up the configuration
# for the phase
# $1: The name of the phase. The output directory and log will be named this.
{
	make_target all 2>&1 | tee "${log_dir}/${phase}.log"
	return ${PIPESTATUS[0]}
}

# ----------------------------------------------------------------------------
default_build()
# ----------------------------------------------------------------------------
{
	build && copy_images
}

# ----------------------------------------------------------------------------
build_toolchain()
# TODO: Make this generically configurable in the config file (i.e. be able
# to define a phase as "protect" or something.
# ----------------------------------------------------------------------------
{
	# Give the user an option to bail out if we detect an already-
	# installed toolchain
	# source the toolchain buildroot config to get the install location
	source "configs/${board}_toolchain_defconfig"
	if [ -d "${BR2_HOST_DIR}" -a $force -eq 0 ] ; then
		echo "Toolchain already exists in ${BR2_HOST_DIR}"
		read -p "Proceed [y/N]? " result
		if [ "$result" != y -a "$result" != Y ] ; then
			echo "Aborting"
			exit 0
		fi
	fi

	default_build
}

# ----------------------------------------------------------------------------
build_rootfs_dev()
# TODO: Use the BR2_ROOTFS_OVERLAY config var instead of hard-coding these
# rootfs image names here.
# ----------------------------------------------------------------------------
{
	require_image rootfs-toolchain.arm.tar.bz2 toolchain || return
	require_image rootfs-bootloader.arm.tar.bz2 bootloader || return
	require_image rootfs-kernel.arm.tar.bz2 kernel || return
	require_image rootfs-basefs-dev.arm.tar.bz2 basefs_dev || return
	default_build
	#copy_image rootfs-dev rootfs-dev.arm.tar.bz2
	#pad_block_size=2k
	#copy_and_pad_image rootfs-dev rootfs-dev.arm.cpio.gz $pad_block_size
}

# ----------------------------------------------------------------------------
build_rootfs()
# TODO: Use the BR2_ROOTFS_OVERLAY config var instead of hard-coding these
# rootfs image names here.
# ----------------------------------------------------------------------------
{
	require_image rootfs-toolchain.arm.tar.bz2 toolchain || return
	require_image rootfs-bootloader.arm.tar.bz2 bootloader || return
	require_image rootfs-kernel.arm.tar.bz2 kernel || return
	require_image rootfs-basefs.arm.tar.bz2 basefs || return
	default_build
	#copy_image rootfs rootfs.arm.tar.bz2
	#pad_block_size=2k
	#copy_and_pad_image rootfs rootfs.arm.cpio.gz $pad_block_size
}

# ============================================================================
# CONFIG target functions
# These functions implement the various config targets, currently
# menuconfig and oldconfig

# ----------------------------------------------------------------------------
create_default_config_if_missing()
# ----------------------------------------------------------------------------
{
	defaultconfig="configs/${board}_toolchain_client_defconfig"

	# Create a default config file if one does not exist
	if [ ! -f "${srcconfig}" ] ; then
		if [ -f "${defaultconfig}" ] ; then
			run cp "${defaultconfig}" "${srcconfig}"
		else
			run touch "${srcconfig}"
		fi
	fi
}

# ----------------------------------------------------------------------------
modify_buildroot_config()
# ----------------------------------------------------------------------------
# modify_buildroot_config make_target
# Run "make <make_target>" for <phase> and save the resulting minimal
# defconfig in the configs directory.
# If there is an existing minimal defconfig for <phase>, it will be used as
# the basis of the menuconfig, otherwise a default config is used.
{
	make_target="$1"

	make_target "${make_target}" \
	&& run ${MAKE} "${make_args[@]}" savedefconfig
}

# ============================================================================

# ----------------------------------------------------------------------------
make_target()
# ----------------------------------------------------------------------------
{
	make_target="$1"

	if [ ! -f "${srcconfig}" ] ; then
		echo "No config for phase ${phase} at ${srcconfig}" >&2
		return 1
	fi

	run ${MAKE} "${make_args[@]}" "${defconfig}" \
	&& run ${MAKE} "${make_args[@]}" "${make_target}"
}

# ----------------------------------------------------------------------------
copy_image()
# ----------------------------------------------------------------------------
# copy_image <image_name> [dest_image_name]
# Copy an image from an output directory into the board saved image directory.
# $1: The name of the image to copy.
# $2: (Optional) The name of the image after copying. If not supplied, the
#     image keeps the same name.
{
	src="$output_location/${phase}/images/$1"
	dest="$image_dir"
	[ -n "$2" ] && dest="$dest/$2"
	run cp -a "$src" "$dest"
}

# ----------------------------------------------------------------------------
copy_images()
# ----------------------------------------------------------------------------
# copy_images
# Copy all images from <phase>'s image directory, except the uncompressed
# rootfs image in there is a compressed one. The rootfs image is renamed
# to include <phase> in its name.
{
	srcdir="$output_location/${phase}/images"
	for src in "${srcdir}"/* ; do
		srcname="${src##*/}"
		if [[ "$srcname" == rootfs.*.* ]] ; then
			newname="${srcname/rootfs/rootfs-${phase}}"
			copy_image "$srcname" "$newname"
		elif [[ "$srcname" == rootfs.* ]] ; then
			# If there's no rootfs.*.* file, copy this one
			if [ ! -f "$src".* ] ; then
				newname="${srcname/rootfs/rootfs-${phase}}"
				copy_image "$srcname" "$newname"
			fi
		else
			copy_image "$srcname"
		fi
	done
}

# ----------------------------------------------------------------------------
copy_and_pad_image()
# ----------------------------------------------------------------------------
# copy_and_pad_image <image_name> <pad_block_size>
# Copy an image from an output directory into the board saved image directory.
# $1: The name of the image to copy.
# $2: Block size to pad image to
{
	src="$output_location"/"${phase}"/images/"$1"
	if [ -f "$src" ] ; then
		run dd if="$src" of="$image_dir"/"$1" bs="$2" conv=sync
	fi
}

# ----------------------------------------------------------------------------
require_image()
# ----------------------------------------------------------------------------
# require_image <image_name> <phase>
# Check that an image is in the saved image directory.
# Returns true (0) if it is there (and is a file), false (1) if it is not.
# If the image is not there, a message is output informing the user what
# phase needs to be built to make the image.
# $1: The name of the required image
# $2: The name of the phase
{
	[ -f "$image_dir"/"$1" ] && return
	echo "Image $1 is required but does not exist"
	echo "Build the phase '$2' to make that image"
	false
}

# ============================================================================
# UTILITY

# ----------------------------------------------------------------------------
phase_has_build_function()
# ----------------------------------------------------------------------------
{
	[ "$(type -t build_${1})" = function ]
}

# ----------------------------------------------------------------------------
known_target()
# ----------------------------------------------------------------------------
{
	[ "$(type -t target_${1})" = function ]
}

# ----------------------------------------------------------------------------
run()
# ----------------------------------------------------------------------------
{
	echo "$@"
	[ $dryrun -ne 0 ] || "$@"
}

# ----------------------------------------------------------------------------
start_tmp()
# ----------------------------------------------------------------------------
# Create a temporary directory and put its name in $tmp_dir. 
# This function will install an EXIT handler so that if the shell script
# exits before the directory is removed then it will get removed on exit.
# The caller should call end_tmp() when they no longer need the temp dir
# Returns true if we could create the tmp_dir, false if not.
{
	[ -z "$tmp_dir" ] || return 1
	trap clean_tmp EXIT
	tmp_dir=$(mktemp -d)
}

# ----------------------------------------------------------------------------
end_tmp()
# ----------------------------------------------------------------------------
# End use of the global temp directory.
# This function will remove the temp directory and EXIT handler.
{
	clean_tmp
}

# ----------------------------------------------------------------------------
clean_tmp()
# ----------------------------------------------------------------------------
# Remove the directory in $tmp_dir if that variable is set.
{
	[ -n "$tmp_dir" ] || return 1
	rm -rf "$tmp_dir"
	tmp_dir=""
	trap - EXIT
}

# ============================================================================
# SETUP
# Functions to read the config and set up the environment that the rest of
# this script depends on

# ----------------------------------------------------------------------------
load_config()
# ----------------------------------------------------------------------------
{
	oldifs="$IFS"
	IFS=:
	local -a xdg=(${XDG_CONFIG_DIRS:-/etc/xdg})
	IFS="$oldifs"
	local -a search=(
		"${xdg[@]/%//brp}"
		"${XDG_CONFIG_HOME:-$HOME/.config}/brp"
		./brp.conf)
	for path in "${search[@]}" ; do
		if [ -f "$path" ] ; then
			source "$path"
		fi
	done
	return 0
}

# ----------------------------------------------------------------------------
check_config()
# ----------------------------------------------------------------------------
{
	[[ -n "${board}" ]] || usage 1 >&2
	[[ -n "${phase}" ]] || usage 1 >&2
	if [[ -z "${buildroot}" ]] ; then
		echo "'buildroot' not set in config. Where is buildroot?" >&2
		return 1
	fi
	return 0
}

# ----------------------------------------------------------------------------
set_vars()
# ----------------------------------------------------------------------------
{
	program_name=${0##*/}

	board="$1"
	phase="$2"
	target="${3:-build}"

	defconfig="${board}_${phase}_defconfig"
	srcconfig="configs/${defconfig}"
	output_location="${output_root:-output}/${board}"
	log_dir="${output_location}"/logs
	image_dir="${output_location}"/images
	tmp_dir=""

	make_args=(
		-C "${buildroot}"
		"O=${output_location}/${phase}"
		"BR2_EXTERNAL=$(pwd)"
	)

	[[ "$V" == '1' ]] && make_args+=("V=1")

	force=0
	dryrun=0
}

# ----------------------------------------------------------------------------
make_output_dirs()
# ----------------------------------------------------------------------------
{
	run mkdir -p "$output_location"
	run mkdir -p "$log_dir"
	run mkdir -p "$image_dir"
}

# ----------------------------------------------------------------------------
[[ "$(caller)" != "0 "* ]] || main "$@"
