#!/bin/bash
#
# buildroot phased build script
#
# This script exists to orchestrate the multiple phases of buildroot that are
# used to generate the toolchain, bootloader, kernel image and the base
# root filesystem.
#

# =============================================================================

MAKE=make

# =============================================================================
# Utility functions

# ----------------------------------------------------------------------------
usage()
# ----------------------------------------------------------------------------
{
	cat <<EOF
Usage: $program_name <board> <phase> [target]
Phases are any name with a <board>_<phase>_deconfig file in the configs/
directory. A phase named "toolchain" is handled specially in that you will
be prompted to overwrite it if it already exists.
Targets are:
  build: Build the phase. This is the default.
  menuconfig: Run make menuconfig on the target, saving the minimal defconfig
    back in the configs directory.
  oldconfig: Run make oldconfig oon the target, saving the minimal defconfig
    back in the configs directory.
  clean: Remove the output directory for the phase.
EOF
	[ -z "${1}" ] || exit "${1}"
}

# ----------------------------------------------------------------------------
main()
# ----------------------------------------------------------------------------
{
	# umask 0022  # fix buildroot bug, temporary
	load_config || exit 1
	set_vars "$@"
	check_config || exit 1

	if ! known_target "${target}" ; then
		echo "Unknown target: ${target}" >&2
	fi
	
	if known_target "${target}" ; then
		eval target_${target} ${phase}
	else
		target_unknown "${target}" "${phase}"
	fi

	return 0
}

# ============================================================================
# TARGETS
# These functions define the top level operations of this script. Currently
# build, menuconfig, oldconfig and clean.
# An unknown target is passed onto the buildroot Makefile, so any buildroot
# target can be used

# ----------------------------------------------------------------------------
target_build()
# ----------------------------------------------------------------------------
{
	if phase_has_build_function "${phase}" ; then
		eval build_${phase}
	else
		default_build
	fi
}

# ----------------------------------------------------------------------------
target_menuconfig()
# ----------------------------------------------------------------------------
{
	make_output_dirs
	modify_buildroot_config menuconfig "$1"
}

# ----------------------------------------------------------------------------
target_oldconfig()
# ----------------------------------------------------------------------------
{
	make_output_dirs
	modify_buildroot_config oldconfig "$1"
}

# ----------------------------------------------------------------------------
target_clean()
# ----------------------------------------------------------------------------
{
	rm -rf "${BRP_OUTPUT_DIR}/${phase}"
}

# ----------------------------------------------------------------------------
target_unknown()
# ----------------------------------------------------------------------------
{
	make_target "$1" "$2"
}

# ============================================================================
# BUILD target functions
# These functions build the images for each specific phases and saves them
# in the board saved image directory. The default build for a phase is to
# call `build` and then copy the resultant images to the image output
# directory. The default can be overridden by implementing a build_<phase>
# function.

# ----------------------------------------------------------------------------
build()
# ----------------------------------------------------------------------------
# build
# Build a phase into its own output directory, logging the process.
# "make $board_<phase>_defconfig" is run first to set up the configuration
# for the phase
# $1: The name of the phase. The output directory and log will be named this.
{
	make_output_dirs
	make_target all 2>&1 | tee "${log_dir}/${phase}.log"
	return ${PIPESTATUS[0]}
}

# ----------------------------------------------------------------------------
default_build()
# ----------------------------------------------------------------------------
{
	build && copy_images
}

# ----------------------------------------------------------------------------
build_toolchain()
# TODO: Make this generically configurable in the config file (i.e. be able
# to define a phase as "protect" or something.
# ----------------------------------------------------------------------------
{
	# Give the user an option to bail out if we detect an already-
	# installed toolchain
	# source the toolchain buildroot config to get the install location
	source "${BRP_BOARD_DIR}/config/toolchain"
	if [ -d "${BR2_HOST_DIR}" -a $force -eq 0 ] ; then
		echo "Toolchain already exists in ${BR2_HOST_DIR}"
		read -p "Proceed [y/N]? " result
		if [ "$result" != y -a "$result" != Y ] ; then
			echo "Aborting"
			exit 0
		fi
	fi

	default_build
}

# ============================================================================
# CONFIG target functions
# These functions implement the various config targets, currently
# menuconfig and oldconfig

# ----------------------------------------------------------------------------
create_default_config_if_missing()
# ----------------------------------------------------------------------------
{
	defaultconfig="${BRP_BOARD_DIR}/toolchain/config/toolchain_client"

	# Create a default config file if one does not exist
	if [ ! -f "${brpconfig}" ] ; then
		if [ -f "${defaultconfig}" ] ; then
			run cp "${defaultconfig}" "${brpconfig}"
		else
			run touch "${brpconfig}"
		fi
	fi
}

# ----------------------------------------------------------------------------
modify_buildroot_config()
# ----------------------------------------------------------------------------
# modify_buildroot_config make_target
# Run "make <make_target>" for <phase> and save the resulting minimal
# defconfig in the configs directory.
# If there is an existing minimal defconfig for <phase>, it will be used as
# the basis of the menuconfig, otherwise a default config is used.
{
	make_target="$1"

	create_default_config_if_missing "$1"

	cp "${brpconfig}" "${srcconfig}" \
	&& make_target "${make_target}" \
	&& run ${MAKE} "${make_args[@]}" savedefconfig \
	&& cp "${srcconfig}" "${brpconfig}"
}

# ============================================================================

# ----------------------------------------------------------------------------
make_target()
# ----------------------------------------------------------------------------
{
	make_target="$1"

	if [ ! -f "${brpconfig}" ] ; then
		echo "No config for phase ${phase} at ${brpconfig}" >&2
		return 1
	fi

	cp "${brpconfig}" "${srcconfig}" \
	&& run ${MAKE} "${make_args[@]}" "${defconfig}" \
	&& run ${MAKE} "${make_args[@]}" "${make_target}"
}

# ----------------------------------------------------------------------------
copy_image()
# ----------------------------------------------------------------------------
# copy_image <image_name> [dest_image_name]
# Copy an image from an output directory into the board saved image directory.
# $1: The name of the image to copy.
# $2: (Optional) The name of the image after copying. If not supplied, the
#     image keeps the same name.
{
	src="${BRP_OUTPUT_DIR}/${phase}/images/$1"
	dest="${BRP_IMAGE_DIR}"
	[ -n "$2" ] && dest="$dest/$2"
	run cp -a "$src" "$dest"
}

# ----------------------------------------------------------------------------
copy_images()
# ----------------------------------------------------------------------------
# copy_images
# Copy all images from <phase>'s image directory, except the uncompressed
# rootfs image in there is a compressed one. The rootfs image is renamed
# to include <phase> in its name.
{
	srcdir="${BRP_OUTPUT_DIR}/${phase}/images"
	for src in "${srcdir}"/* ; do
		srcname="${src##*/}"
		if [[ "$srcname" == rootfs.*.* ]] ; then
			newname="${srcname/rootfs/rootfs-${phase}}"
			copy_image "$srcname" "$newname"
		elif [[ "$srcname" == rootfs.* ]] ; then
			# If there's no rootfs.*.* file, copy this one
			if [ ! -f "$src".* ] ; then
				newname="${srcname/rootfs/rootfs-${phase}}"
				copy_image "$srcname" "$newname"
			fi
		else
			copy_image "$srcname"
		fi
	done
}

# ============================================================================
# UTILITY

# ----------------------------------------------------------------------------
phase_has_build_function()
# ----------------------------------------------------------------------------
{
	[ "$(type -t build_${1})" = function ]
}

# ----------------------------------------------------------------------------
known_target()
# ----------------------------------------------------------------------------
{
	[ "$(type -t target_${1})" = function ]
}

# ----------------------------------------------------------------------------
run()
# ----------------------------------------------------------------------------
{
	echo "$@"
	[ $dryrun -ne 0 ] || "$@"
}

# ----------------------------------------------------------------------------
start_tmp()
# ----------------------------------------------------------------------------
# Create a temporary directory and put its name in $tmp_dir. 
# This function will install an EXIT handler so that if the shell script
# exits before the directory is removed then it will get removed on exit.
# The caller should call end_tmp() when they no longer need the temp dir
# Returns true if we could create the tmp_dir, false if not.
{
	[ -z "$tmp_dir" ] || return 1
	trap clean_tmp EXIT
	tmp_dir=$(mktemp -d)
}

# ----------------------------------------------------------------------------
end_tmp()
# ----------------------------------------------------------------------------
# End use of the global temp directory.
# This function will remove the temp directory and EXIT handler.
{
	clean_tmp
}

# ----------------------------------------------------------------------------
clean_tmp()
# ----------------------------------------------------------------------------
# Remove the directory in $tmp_dir if that variable is set.
{
	[ -n "$tmp_dir" ] || return 1
	rm -rf "$tmp_dir"
	tmp_dir=""
	trap - EXIT
}

# ============================================================================
# SETUP
# Functions to read the config and set up the environment that the rest of
# this script depends on

# ----------------------------------------------------------------------------
load_config()
# ----------------------------------------------------------------------------
{
	oldifs="$IFS"
	IFS=:
	local -a xdg=(${XDG_CONFIG_DIRS:-/etc/xdg})
	IFS="$oldifs"
	local -a search=(
		"${xdg[@]/%//brp}"
		"${XDG_CONFIG_HOME:-$HOME/.config}/brp"
		./brp.conf)
	for path in "${search[@]}" ; do
		if [ -f "$path" ] ; then
			source "$path"
		fi
	done
	return 0
}

# ----------------------------------------------------------------------------
check_config()
# ----------------------------------------------------------------------------
{
	[[ -n "${board}" ]] || usage 1 >&2
	[[ -n "${phase}" ]] || usage 1 >&2
	if [[ -z "${buildroot}" ]] ; then
		echo "'buildroot' not set in config. Where is buildroot?" >&2
		return 1
	fi
	if ! [[ -d "${BRP_BOARD_DIR}" ]] ; then
		echo "board dir missing: ${BRP_BOARD_DIR}" >&2
		return 1
	fi
	return 0
}

# ----------------------------------------------------------------------------
set_vars()
# ----------------------------------------------------------------------------
{
	program_name=${0##*/}

	board="$1"
	phase="$2"
	target="${3:-build}"

	# $output_root can be defined in brp.conf
	# TODO(camh): Check whether default relative path "output" works
	BRP_OUTPUT_DIR="${output_root:-output}/${board}"
	BRP_IMAGE_DIR="${BRP_OUTPUT_DIR}"/images
	BRP_BOARD_DIR="${PWD}/board/${board}"

	defconfig="${board}_${phase}_defconfig"
	srcconfig="configs/${defconfig}"
	brpconfig="${BRP_BOARD_DIR}/config/${phase}"

	log_dir="${BRP_OUTPUT_DIR}"/logs
	tmp_dir=""

	make_args=(
		-C "${buildroot}"
		"O=${BRP_OUTPUT_DIR}/${phase}"
		"BR2_EXTERNAL=$(pwd)"
	)

	[[ "$V" == '1' ]] && make_args+=("V=1")

	force=0
	dryrun=0

	export BRP_OUTPUT_DIR BRP_IMAGE_DIR BRP_BOARD_DIR
}

# ----------------------------------------------------------------------------
make_output_dirs()
# ----------------------------------------------------------------------------
{
	run mkdir -p "${BRP_OUTPUT_DIR}"
	run mkdir -p "${BRP_IMAGE_DIR}"
	run mkdir -p "${log_dir}"
}

# ----------------------------------------------------------------------------
[[ "$(caller)" != "0 "* ]] || main "$@"
